функция по удалению erc20:     function removeERC20(uint256 _tokenId, address _erc20Contract, uint256 _value) private {

        if (_value == 0) {
            return;
        }
        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract]; //переменная содержащая в себе баланс erc20
        require(erc20Balance >= _value, "Not enough token available to transfer.");
        uint256 newERC20Balance = erc20Balance - _value; // обновление баланса erc20
        erc20Balances[_tokenId][_erc20Contract] = newERC20Balance; // обновление баланса erc20
        if (newERC20Balance == 0) { //если баланс erc20 равен 0
            uint256 lastContractIndex = erc20Contracts[_tokenId].length - 1;   //мы уменьшаем количество erc20????
            address lastContract = erc20Contracts[_tokenId][lastContractIndex]; //
            if (_erc20Contract != lastContract) {
                uint256 contractIndex = erc20ContractIndex[_tokenId][_erc20Contract];
                erc20Contracts[_tokenId][contractIndex] = lastContract;
                erc20ContractIndex[_tokenId][lastContract] = contractIndex;
            }
            erc20Contracts[_tokenId].length--;
            delete erc20ContractIndex[_tokenId][_erc20Contract];
        }
    }

функция по пересылке erc20:    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external {
        require(_to != address(0)); // чтобы не было отправки самому себе
        address rootOwner = address(rootOwnerOf(_tokenId)); //получаем адрес rootOwner токена(erc721)
        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] || rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender); //проверка
        removeERC20(_tokenId, _erc20Contract, _value); //вызываем функцию удаления removeERC20
        require(ERC20AndERC223(_erc20Contract).transfer(_to, _value), "ERC20 transfer failed."); //проверка трансфера
        emit TransferERC20(_tokenId, _to, _erc20Contract, _value); //запись события трансфера
    }

функция получения erc20:    function erc20Received(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) private {

        require(tokenIdToTokenOwner[_tokenId] != address(0), "_tokenId does not exist."); //проверка на существование токена
        if (_value == 0) {
            return;
        }
        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract]; // баланс erc20 на счету токена
        if (erc20Balance == 0) { //если не токенов, то мы удаляем что-то
            erc20ContractIndex[_tokenId][_erc20Contract] = erc20Contracts[_tokenId].length;
            erc20Contracts[_tokenId].push(_erc20Contract);
        }
        erc20Balances[_tokenId][_erc20Contract] += _value; //пополняем число баланса
        emit ReceivedERC20(_from, _tokenId, _erc20Contract, _value); //записываем события
    }

функция определения владельца erc20:    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address) {
проверка баланса erc20:     function balanceOfERC20(uint256 _tokenId, address _erc20Contract) external view returns (uint256) {
и для erc20 не составляется дерева наследования

общее количество erc20 контрактов: 
    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256) {
        return erc20Contracts[_tokenId].length;
    }



зачем-то 4 функции передачи erc721:    function _transferFrom(address _from, address _to, uint256 _tokenId) private {
    function transferFrom(address _from, address _to, uint256 _tokenId) external {
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {

получение дочернего токена:        function receiveChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) private {
        require(tokenIdToTokenOwner[_tokenId] != address(0), "_tokenId does not exist.");
        require(childTokenIndex[_tokenId][_childContract][_childTokenId] == 0, "Cannot receive child token because it has already been received.");
        uint256 childTokensLength = childTokens[_tokenId][_childContract].length;
        if (childTokensLength == 0) {
            childContractIndex[_tokenId][_childContract] = childContracts[_tokenId].length;
            childContracts[_tokenId].push(_childContract);
        }
        childTokens[_tokenId][_childContract].push(_childTokenId);
        childTokenIndex[_tokenId][_childContract][_childTokenId] = childTokensLength + 1;
        childTokenOwner[_childContract][_childTokenId] = _tokenId;
        emit ReceivedChild(_from, _tokenId, _childContract, _childTokenId);
    }



    function childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId) {



